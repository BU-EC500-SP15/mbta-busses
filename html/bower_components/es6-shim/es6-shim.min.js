// ES6-shim 0.10.1 (c) 2013-2014 Paul Miller (http://paulmillr.com)
// ES6-shim may be freely distributed under the MIT license.
// For more details and documentation:
// https://github.com/paulmillr/es6-shim/
(function(a){"use strict";var b=function(a){try{a()}catch(b){return false}return true};var c=function(a,b){/* jshint proto:true */
try{var c=function(){a.apply(this,arguments)};if(!c.__proto__){return false}Object.setPrototypeOf(c,a);c.prototype=Object.create(a.prototype,{constructor:{value:a}});return b(c)}catch(d){return false}};var d=function(){try{Object.defineProperty({},"x",{});return true}catch(a){/* this is IE 8. */
return false}};var e=function(){var a=false;if(String.prototype.startsWith){try{"/a/".startsWith(/a/)}catch(b){/* this is spec compliant */
a=true}}return a};var f=function(){var f=typeof global==="undefined"?window:global;var g=f.isFinite;var h=!!Object.defineProperty&&d();var i=e();var j=Array.prototype.slice;var k=String.prototype.indexOf;var l=Object.prototype.toString;var m=Object.prototype.hasOwnProperty;// Define configurable, writable and non-enumerable props
// if they donâ€™t exist.
var n=function(a,b){Object.keys(b).forEach(function(c){var d=b[c];if(c in a)return;if(h){Object.defineProperty(a,c,{configurable:true,enumerable:false,writable:true,value:d})}else{a[c]=d}})};// This is a private name in the es6 spec, equal to '[Symbol.iterator]'
// we're going to use an arbitrary _-prefixed name to make our shims
// work properly with each other, even though we don't have full Iterator
// support.  That is, `Array.from(map.keys())` will work, but we don't
// pretend to export a "real" Iterator interface.
var o=typeof Symbol==="object"&&Symbol.iterator||"_es6shim_iterator_";// Firefox ships a partial implementation using the name @@iterator.
// https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
// So use that name if we detect it.
if(f.Set&&typeof(new f.Set)["@@iterator"]==="function"){o="@@iterator"}var p=function(a,b){if(!b){b=function d(){return this}}var c={};c[o]=b;n(a,c)};// taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
// can be replaced with require('is-arguments') if we ever use a build process instead
var q=function E(a){var b=l.call(a);var c=b==="[object Arguments]";if(!c){c=b!=="[object Array]"&&a!==null&&typeof a==="object"&&typeof a.length==="number"&&a.length>=0&&l.call(a.callee)==="[object Function]"}return c};var r=function(a){if(!s.TypeIsObject(a))throw new TypeError("bad object");// es5 approximation to es6 subclass semantics: in es6, 'new Foo'
// would invoke Foo.@@create to allocation/initialize the new object.
// In es5 we just get the plain object.  So if we detect an
// uninitialized object, invoke o.constructor.@@create
if(!a._es6construct){if(a.constructor&&s.IsCallable(a.constructor["@@create"])){a=a.constructor["@@create"](a)}n(a,{_es6construct:true})}return a};var s={CheckObjectCoercible:function(a,b){/* jshint eqnull:true */
if(a==null)throw new TypeError(b||"Cannot call method on "+a);return a},TypeIsObject:function(a){/* jshint eqnull:true */
// this is expensive when it returns false; use this function
// when you expect it to return true in the common case.
return a!=null&&Object(a)===a},ToObject:function(a,b){return Object(s.CheckObjectCoercible(a,b))},IsCallable:function(a){// some versions of IE say that typeof /abc/ === 'function'
return typeof a==="function"&&l.call(a)==="[object Function]"},ToInt32:function(a){return a>>0},ToUint32:function(a){return a>>>0},ToInteger:function(a){var b=+a;if(Number.isNaN(b))return 0;if(b===0||!Number.isFinite(b))return b;return Math.sign(b)*Math.floor(Math.abs(b))},ToLength:function(a){var b=s.ToInteger(a);if(b<=0)return 0;// includes converting -0 to +0
if(b>Number.MAX_SAFE_INTEGER)return Number.MAX_SAFE_INTEGER;return b},SameValue:function(a,b){if(a===b){// 0 === -0, but they are not identical.
if(a===0)return 1/a===1/b;return true}return Number.isNaN(a)&&Number.isNaN(b)},SameValueZero:function(a,b){// same as SameValue except for SameValueZero(+0, -0) == true
return a===b||Number.isNaN(a)&&Number.isNaN(b)},IsIterable:function(b){return s.TypeIsObject(b)&&(b[o]!==a||q(b))},GetIterator:function(a){if(q(a)){// special case support for `arguments`
return new ArrayIterator(a,"value")}var b=a[o]();if(!s.TypeIsObject(b)){throw new TypeError("bad iterator")}return b},IteratorNext:function(a){var b=arguments.length>1?a.next(arguments[1]):a.next();if(!s.TypeIsObject(b)){throw new TypeError("bad iterator")}return b},Construct:function(a,b){// CreateFromConstructor
var c;if(s.IsCallable(a["@@create"])){c=a["@@create"]()}else{// OrdinaryCreateFromConstructor
c=Object.create(a.prototype||null)}// Mark that we've used the es6 construct path
// (see emulateES6construct)
n(c,{_es6construct:true});// Call the constructor.
var d=a.apply(c,b);return s.TypeIsObject(d)?d:c}};var t=function(){// from https://github.com/inexorabletash/polyfill/blob/master/typedarray.js#L176-L266
// with permission and license, per https://twitter.com/inexorabletash/status/372206509540659200
function a(a){var b=Math.floor(a),c=a-b;if(c<.5){return b}if(c>.5){return b+1}return b%2?b+1:b}function b(b,c,d){var e=(1<<c-1)-1,f,g,h,i,j,k,l,m;// Compute sign, exponent, fraction
if(b!==b){// NaN
// http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
g=(1<<c)-1;h=Math.pow(2,d-1);f=0}else if(b===Infinity||b===-Infinity){g=(1<<c)-1;h=0;f=b<0?1:0}else if(b===0){g=0;h=0;f=1/b===-Infinity?1:0}else{f=b<0;b=Math.abs(b);if(b>=Math.pow(2,1-e)){g=Math.min(Math.floor(Math.log(b)/Math.LN2),1023);h=a(b/Math.pow(2,g)*Math.pow(2,d));if(h/Math.pow(2,d)>=2){g=g+1;h=1}if(g>e){// Overflow
g=(1<<c)-1;h=0}else{// Normal
g=g+e;h=h-Math.pow(2,d)}}else{// Subnormal
g=0;h=a(b/Math.pow(2,1-e-d))}}// Pack sign, exponent, fraction
k=[];for(j=d;j;j-=1){k.push(h%2?1:0);h=Math.floor(h/2)}for(j=c;j;j-=1){k.push(g%2?1:0);g=Math.floor(g/2)}k.push(f?1:0);k.reverse();l=k.join("");// Bits to bytes
m=[];while(l.length){m.push(parseInt(l.substring(0,8),2));l=l.substring(8)}return m}function c(a,b,c){// Bytes to bits
var d=[],e,f,g,h,i,j,k,l;for(e=a.length;e;e-=1){g=a[e-1];for(f=8;f;f-=1){d.push(g%2?1:0);g=g>>1}}d.reverse();h=d.join("");// Unpack sign, exponent, fraction
i=(1<<b-1)-1;j=parseInt(h.substring(0,1),2)?-1:1;k=parseInt(h.substring(1,1+b),2);l=parseInt(h.substring(1+b),2);// Produce number
if(k===(1<<b)-1){return l!==0?NaN:j*Infinity}else if(k>0){// Normalized
return j*Math.pow(2,k-i)*(1+l/Math.pow(2,c))}else if(l!==0){// Denormalized
return j*Math.pow(2,-(i-1))*(l/Math.pow(2,c))}else{return j<0?-0:0}}function d(a){return c(a,11,52)}function e(a){return b(a,11,52)}function f(a){return c(a,8,23)}function g(a){return b(a,8,23)}var h={toFloat32:function(a){return f(g(a))}};if(typeof Float32Array!=="undefined"){var i=new Float32Array(1);h.toFloat32=function(a){i[0]=a;return i[0]}}return h}();n(String,{fromCodePoint:function(){var a=j.call(arguments,0,arguments.length);var b=[];var c;for(var d=0,e=a.length;d<e;d++){c=Number(a[d]);if(!s.SameValue(c,s.ToInteger(c))||c<0||c>1114111){throw new RangeError("Invalid code point "+c)}if(c<65536){b.push(String.fromCharCode(c))}else{c-=65536;b.push(String.fromCharCode((c>>10)+55296));b.push(String.fromCharCode(c%1024+56320))}}return b.join("")},raw:function(b){// raw.length===1
var c=j.call(arguments,1,arguments.length);var d=s.ToObject(b,"bad callSite");var e=d.raw;var f=s.ToObject(e,"bad raw value");var g=Object.keys(f).length;var h=s.ToLength(g);if(h===0){return""}var i=[];var k=0;var l,m,n,o;while(k<h){l=String(k);m=f[l];n=String(m);i.push(n);if(k+1>=h){break}m=c[l];if(m===a){break}o=String(m);i.push(o);k++}return i.join("")}});var u={// Fast repeat, uses the `Exponentiation by squaring` algorithm.
// Perf: http://jsperf.com/string-repeat2/2
repeat:function(){var a=function(b,c){if(c<1)return"";if(c%2)return a(b,c-1)+b;var d=a(b,c/2);return d+d};return function(b){var c=String(s.CheckObjectCoercible(this));b=s.ToInteger(b);if(b<0||b===Infinity){throw new RangeError("Invalid String#repeat value")}return a(c,b)}}(),startsWith:function(b){var c=String(s.CheckObjectCoercible(this));if(l.call(b)==="[object RegExp]")throw new TypeError('Cannot call method "startsWith" with a regex');b=String(b);var d=arguments.length>1?arguments[1]:a;var e=Math.max(s.ToInteger(d),0);return c.slice(e,e+b.length)===b},endsWith:function(b){var c=String(s.CheckObjectCoercible(this));if(l.call(b)==="[object RegExp]")throw new TypeError('Cannot call method "endsWith" with a regex');b=String(b);var d=c.length;var e=arguments.length>1?arguments[1]:a;var f=e===a?d:s.ToInteger(e);var g=Math.min(Math.max(f,0),d);return c.slice(g-b.length,g)===b},contains:function(b){var c=arguments.length>1?arguments[1]:a;// Somehow this trick makes method 100% compat with the spec.
return k.call(this,b,c)!==-1},codePointAt:function(b){var c=String(s.CheckObjectCoercible(this));var d=s.ToInteger(b);var e=c.length;if(d<0||d>=e)return a;var f=c.charCodeAt(d);var g=d+1===e;if(f<55296||f>56319||g)return f;var h=c.charCodeAt(d+1);if(h<56320||h>57343)return f;return(f-55296)*1024+(h-56320)+65536}};n(String.prototype,u);// see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype-@@iterator
var v=function(a){this._s=String(s.CheckObjectCoercible(a));this._i=0};v.prototype.next=function(){var b=this._s,c=this._i;if(b===a||c>=b.length){this._s=a;return{value:a,done:true}}var d=b.charCodeAt(c),e,f;if(d<55296||d>56319||c+1==b.length){f=1}else{e=b.charCodeAt(c+1);f=e<56320||e>57343?1:2}this._i=c+f;return{value:b.substr(c,f),done:false}};p(v.prototype);p(String.prototype,function(){return new v(this)});if(!i){// Firefox has a noncompliant startsWith implementation
String.prototype.startsWith=u.startsWith;String.prototype.endsWith=u.endsWith}n(Array,{from:function(b){var c=arguments.length>1?arguments[1]:a;var d=arguments.length>2?arguments[2]:a;var e=s.ToObject(b,"bad iterable");if(c!==a&&!s.IsCallable(c)){throw new TypeError("Array.from: when provided, the second argument must be a function")}var f=s.IsIterable(e);// does the spec really mean that Arrays should use ArrayIterator?
// https://bugs.ecmascript.org/show_bug.cgi?id=2416
//if (Array.isArray(list)) { usingIterator=false; }
var g=f?0:s.ToLength(e.length);var h=s.IsCallable(this)?Object(f?new this:new this(g)):new Array(g);var i=f?s.GetIterator(e):null;var j;for(var k=0;f||k<g;k++){if(f){j=s.IteratorNext(i);if(j.done){g=k;break}j=j.value}else{j=e[k]}if(c!==a){h[k]=d?c.call(d,j):c(j)}else{h[k]=j}}h.length=g;return h},of:function(){return Array.from(arguments)}});n(f,{ArrayIterator:function(a,b){this.i=0;this.array=a;this.kind=b}});n(ArrayIterator.prototype,{next:function(){var b=this.i,c=this.array;if(b===a||this.kind===a){throw new TypeError("Not an ArrayIterator")}if(c!==a){var d=s.ToLength(c.length);for(;b<d;b++){var e=this.kind;var f;if(e==="key"){f=b}if(e==="value"){f=c[b]}if(e==="entry"){f=[b,c[b]]}this.i=b+1;return{value:f,done:false}}}this.array=a;return{value:a,done:true}}});p(ArrayIterator.prototype);n(Array.prototype,{copyWithin:function(b,c){var d=arguments[2];// copyWithin.length must be 2
var e=s.ToObject(this);var f=s.ToLength(e.length);b=s.ToInteger(b);c=s.ToInteger(c);var g=b<0?Math.max(f+b,0):Math.min(b,f);var h=c<0?Math.max(f+c,0):Math.min(c,f);d=d===a?f:s.ToInteger(d);var i=d<0?Math.max(f+d,0):Math.min(d,f);var j=Math.min(i-h,f-g);var k=1;if(h<g&&g<h+j){k=-1;h+=j-1;g+=j-1}while(j>0){if(m.call(e,h)){e[g]=e[h]}else{delete e[h]}h+=k;g+=k;j-=1}return e},fill:function(b){var c=arguments[1],d=arguments[2];// fill.length===1
var e=s.ToObject(this);var f=s.ToLength(e.length);c=s.ToInteger(c===a?0:c);d=s.ToInteger(d===a?f:d);var g=c<0?Math.max(f+c,0):Math.min(c,f);for(var h=g;h<f&&h<d;++h){e[h]=b}return e},find:function(b){var c=s.ToObject(this);var d=s.ToLength(c.length);if(!s.IsCallable(b)){throw new TypeError("Array#find: predicate must be a function")}var e=arguments[1];for(var f=0,g;f<d;f++){if(f in c){g=c[f];if(b.call(e,g,f,c))return g}}return a},findIndex:function(a){var b=s.ToObject(this);var c=s.ToLength(b.length);if(!s.IsCallable(a)){throw new TypeError("Array#findIndex: predicate must be a function")}var d=arguments[1];for(var e=0;e<c;e++){if(e in b){if(a.call(d,b[e],e,b))return e}}return-1},keys:function(){return new ArrayIterator(this,"key")},values:function(){return new ArrayIterator(this,"value")},entries:function(){return new ArrayIterator(this,"entry")}});p(Array.prototype,function(){return this.values()});// Chrome defines keys/values/entries on Array, but doesn't give us
// any way to identify its iterator.  So add our own shimmed field.
p(Object.getPrototypeOf([].values()));var w=Math.pow(2,53)-1;n(Number,{MAX_SAFE_INTEGER:w,MIN_SAFE_INTEGER:-w,EPSILON:2.220446049250313e-16,parseInt:f.parseInt,parseFloat:f.parseFloat,isFinite:function(a){return typeof a==="number"&&g(a)},isInteger:function(a){return typeof a==="number"&&!Number.isNaN(a)&&Number.isFinite(a)&&s.ToInteger(a)===a},isSafeInteger:function(a){return Number.isInteger(a)&&Math.abs(a)<=Number.MAX_SAFE_INTEGER},isNaN:function(a){// NaN !== NaN, but they are identical.
// NaNs are the only non-reflexive value, i.e., if x !== x,
// then x is NaN.
// isNaN is broken: it converts its argument to number, so
// isNaN('foo') => true
return a!==a}});n(Number.prototype,{});if(h){n(Object,{getOwnPropertyDescriptors:function(a){var b={};Object.getOwnPropertyNames(a).forEach(function(c){b[c]=Object.getOwnPropertyDescriptor(a,c)});return b},getPropertyDescriptor:function(b,c){var d=Object.getOwnPropertyDescriptor(b,c);var e=Object.getPrototypeOf(b);while(d===a&&e!==null){d=Object.getOwnPropertyDescriptor(e,c);e=Object.getPrototypeOf(e)}return d},getPropertyNames:function(a){var b=Object.getOwnPropertyNames(a);var c=Object.getPrototypeOf(a);var d=function(a){if(b.indexOf(a)===-1){b.push(a)}};while(c!==null){Object.getOwnPropertyNames(c).forEach(d);c=Object.getPrototypeOf(c)}return b},// 19.1.3.1
assign:function(a,b){return Object.keys(b).reduce(function(a,c){a[c]=b[c];return a},a)}});// 19.1.3.9
// shim from https://gist.github.com/WebReflection/5593554
n(Object,{setPrototypeOf:function(a,b){var c;var d=function(a,b){if(!s.TypeIsObject(a)){throw new TypeError("cannot set prototype on a non-object")}if(!(b===null||s.TypeIsObject(b))){throw new TypeError("can only set prototype to an object or null"+b)}};var e=function(a,b){d(a,b);c.call(a,b);return a};try{// this works already in Firefox and Safari
c=a.getOwnPropertyDescriptor(a.prototype,b).set;c.call({},null)}catch(f){if(a.prototype!=={}[b]){// IE < 11 cannot be shimmed
return}// probably Chrome or some old Mobile stock browser
c=function(a){this[b]=a};// please note that this will **not** work
// in those browsers that do not inherit
// __proto__ by mistake from Object.prototype
// in these cases we should probably throw an error
// or at least be informed about the issue
e.polyfill=e(e({},null),a.prototype)instanceof a}return e}(Object,"__proto__")})}// Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,
// but Object.create(null) does.
if(Object.setPrototypeOf&&Object.getPrototypeOf&&Object.getPrototypeOf(Object.setPrototypeOf({},null))!==null&&Object.getPrototypeOf(Object.create(null))===null){(function(){var a=Object.create(null);var b=Object.getPrototypeOf,c=Object.setPrototypeOf;Object.getPrototypeOf=function(c){var d=b(c);return d===a?null:d};Object.setPrototypeOf=function(b,d){if(d===null){d=a}return c(b,d)};Object.setPrototypeOf.polyfill=false})()}n(Object,{getOwnPropertyKeys:function(a){return Object.keys(a)},is:function(a,b){return s.SameValue(a,b)}});try{Object.keys("foo")}catch(x){var y=Object.keys;Object.keys=function(a){return y(s.ToObject(a))}}var z={acosh:function(a){a=Number(a);if(Number.isNaN(a)||a<1)return NaN;if(a===1)return 0;if(a===Infinity)return a;return Math.log(a+Math.sqrt(a*a-1))},asinh:function(a){a=Number(a);if(a===0||!g(a)){return a}return a<0?-Math.asinh(-a):Math.log(a+Math.sqrt(a*a+1))},atanh:function(a){a=Number(a);if(Number.isNaN(a)||a<-1||a>1){return NaN}if(a===-1)return-Infinity;if(a===1)return Infinity;if(a===0)return a;return.5*Math.log((1+a)/(1-a))},cbrt:function(a){a=Number(a);if(a===0)return a;var b=a<0,c;if(b)a=-a;c=Math.pow(a,1/3);return b?-c:c},clz32:function(a){// See https://bugs.ecmascript.org/show_bug.cgi?id=2465
a=Number(a);if(Number.isNaN(a))return NaN;var b=s.ToUint32(a);if(b===0){return 32}return 32-b.toString(2).length},cosh:function(a){a=Number(a);if(a===0)return 1;// +0 or -0
if(Number.isNaN(a))return NaN;if(!g(a))return Infinity;if(a<0)a=-a;if(a>21)return Math.exp(a)/2;return(Math.exp(a)+Math.exp(-a))/2},expm1:function(a){a=Number(a);if(a===-Infinity)return-1;if(!g(a)||a===0)return a;var b=0;var c=50;for(var d=1;d<c;d++){for(var e=2,f=1;e<=d;e++){f*=e}b+=Math.pow(a,d)/f}return b},hypot:function(a,b){var c=false;var d=true;var e=false;var f=[];Array.prototype.every.call(arguments,function(a){var b=Number(a);if(Number.isNaN(b))c=true;else if(b===Infinity||b===-Infinity)e=true;else if(b!==0)d=false;if(e){return false}else if(!c){f.push(Math.abs(b))}return true});if(e)return Infinity;if(c)return NaN;if(d)return 0;f.sort(function(a,b){return b-a});var g=f[0];var h=f.map(function(a){return a/g});var i=h.reduce(function(a,b){return a+=b*b},0);return g*Math.sqrt(i)},log2:function(a){return Math.log(a)*Math.LOG2E},log10:function(a){return Math.log(a)*Math.LOG10E},log1p:function(a){a=Number(a);if(a<-1||Number.isNaN(a))return NaN;if(a===0||a===Infinity)return a;if(a===-1)return-Infinity;var b=0;var c=50;if(a<0||a>1)return Math.log(1+a);for(var d=1;d<c;d++){if(d%2===0){b-=Math.pow(a,d)/d}else{b+=Math.pow(a,d)/d}}return b},sign:function(a){var b=+a;if(b===0)return b;if(Number.isNaN(b))return b;return b<0?-1:1},sinh:function(a){a=Number(a);if(!g(a)||a===0)return a;return(Math.exp(a)-Math.exp(-a))/2},tanh:function(a){a=Number(a);if(Number.isNaN(a)||a===0)return a;if(a===Infinity)return 1;if(a===-Infinity)return-1;return(Math.exp(a)-Math.exp(-a))/(Math.exp(a)+Math.exp(-a))},trunc:function(a){var b=Number(a);return b<0?-Math.floor(-b):Math.floor(b)},imul:function(a,b){// taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
var c=a>>>16&65535;var d=a&65535;var e=b>>>16&65535;var f=b&65535;// the shift by 0 fixes the sign on the high part
// the final |0 converts the unsigned value into a signed value
return d*f+(c*f+d*e<<16>>>0)|0},fround:function(a){if(a===0||a===Infinity||a===-Infinity||Number.isNaN(a)){return a}var b=Number(a);return t.toFloat32(b)}};n(Math,z);if(Math.imul(4294967295,5)!==-5){// Safari 6.1, at least, reports "0" for this value
Math.imul=z.imul}// Promises
// Simplest possible implementation; use a 3rd-party library if you
// want the best possible speed and/or long stack traces.
var A=function(){var b,c;s.IsPromise=function(b){if(!s.TypeIsObject(b)){return false}if(!b._promiseConstructor){// _promiseConstructor is a bit more unique than _status, so we'll
// check that instead of the [[PromiseStatus]] internal field.
return false}if(b._status===a){return false}return true};// "PromiseCapability" in the spec is what most promise implementations
// call a "deferred".
var d=function(a){if(!s.IsCallable(a)){throw new TypeError("bad promise constructor")}var b=this;var c=function(a,c){b.resolve=a;b.reject=c};b.promise=s.Construct(a,[c]);// see https://bugs.ecmascript.org/show_bug.cgi?id=2478
if(!b.promise._es6construct){throw new TypeError("bad promise constructor")}if(!(s.IsCallable(b.resolve)&&s.IsCallable(b.reject))){throw new TypeError("bad promise constructor")}};// find an appropriate setImmediate-alike
var e=f.setTimeout;var g=function(){// from http://dbaron.org/log/20100309-faster-timeouts
var a=[];var b="zero-timeout-message";var c=function(c){a.push(c);window.postMessage(b,"*")};var d=function(c){if(c.source==window&&c.data==b){c.stopPropagation();if(a.length===0){return}var d=a.shift();d()}};window.addEventListener("message",d,true);return c};var h=s.IsCallable(f.setImmediate)?f.setImmediate.bind(f):typeof process==="object"&&process.nextTick?process.nextTick:s.IsCallable(window.postMessage)?g():function(a){e(a,0)};// fallback
var i=function(a,b){a.forEach(function(a){h(function(){// PromiseReactionTask
var c=a.handler;var d=a.capability;var e=d.resolve;var f=d.reject;try{var g=c(b);if(g===d.promise){throw new TypeError("self resolution")}var h=j(g,d);if(!h){e(g)}}catch(i){f(i)}})})};var j=function(a,b){if(!s.TypeIsObject(a)){return false}var c=b.resolve;var d=b.reject;try{var e=a.then;// only one invocation of accessor
if(!s.IsCallable(e)){return false}e.call(a,c,d)}catch(f){d(f)}return true};var k=function(a,b,c){return function(e){if(e===a){return c(new TypeError("self resolution"))}var f=a._promiseConstructor;var g=new d(f);var h=j(e,g);if(h){return g.promise.then(b,c)}else{return b(e)}}};b=function(b){var c=this;c=r(c);if(!c._promiseConstructor){// we use _promiseConstructor as a stand-in for the internal
// [[PromiseStatus]] field; it's a little more unique.
throw new TypeError("bad promise")}if(c._status!==a){throw new TypeError("promise already initialized")}// see https://bugs.ecmascript.org/show_bug.cgi?id=2482
if(!s.IsCallable(b)){throw new TypeError("not a valid resolver")}c._status="unresolved";c._resolveReactions=[];c._rejectReactions=[];var d=function(b){if(c._status!=="unresolved"){return}var d=c._resolveReactions;c._result=b;c._resolveReactions=a;c._rejectReactions=a;c._status="has-resolution";i(d,b)};var e=function(b){if(c._status!=="unresolved"){return}var d=c._rejectReactions;c._result=b;c._resolveReactions=a;c._rejectReactions=a;c._status="has-rejection";i(d,b)};try{b(d,e)}catch(f){e(f)}return c};c=b.prototype;n(b,{"@@create":function(b){var d=this;// AllocatePromise
// The `obj` parameter is a hack we use for es5
// compatibility.
var e=d.prototype||c;b=b||Object.create(e);n(b,{_status:a,_result:a,_resolveReactions:a,_rejectReactions:a,_promiseConstructor:a});b._promiseConstructor=d;return b}});var l=function(a,b,c,d){var e=false;return function(f){if(e){return}// protect against being called multiple times
e=true;b[a]=f;if(--d.count===0){var g=c.resolve;g(b)}}};b.all=function(a){var b=this;var c=new d(b);var e=c.resolve;var f=c.reject;try{if(!s.IsIterable(a)){throw new TypeError("bad iterable")}var g=s.GetIterator(a);var h=[],i={count:1};for(var j=0;;j++){var k=s.IteratorNext(g);if(k.done){break}var m=b.resolve(k.value);var n=l(j,h,c,i);i.count++;m.then(n,c.reject)}if(--i.count===0){e(h)}}catch(o){f(o)}return c.promise};b.race=function(a){var b=this;var c=new d(b);var e=c.resolve;var f=c.reject;try{if(!s.IsIterable(a)){throw new TypeError("bad iterable")}var g=s.GetIterator(a);while(true){var h=s.IteratorNext(g);if(h.done){// If iterable has no items, resulting promise will never
// resolve; see:
// https://github.com/domenic/promises-unwrapping/issues/75
// https://bugs.ecmascript.org/show_bug.cgi?id=2515
break}var i=b.resolve(h.value);i.then(e,f)}}catch(j){f(j)}return c.promise};b.reject=function(a){var b=this;var c=new d(b);var e=c.reject;e(a);// call with this===undefined
return c.promise};b.resolve=function(a){var b=this;if(s.IsPromise(a)){var c=a._promiseConstructor;if(c===b){return a}}var e=new d(b);var f=e.resolve;f(a);// call with this===undefined
return e.promise};b.prototype["catch"]=function(b){return this.then(a,b)};b.prototype.then=function(a,b){var c=this;if(!s.IsPromise(c)){throw new TypeError("not a promise")}// this.constructor not this._promiseConstructor; see
// https://bugs.ecmascript.org/show_bug.cgi?id=2513
var e=this.constructor;var f=new d(e);if(!s.IsCallable(b)){b=function(a){throw a}}if(!s.IsCallable(a)){a=function(a){return a}}var g=k(c,a,b);var h={capability:f,handler:g};var j={capability:f,handler:b};switch(c._status){case"unresolved":c._resolveReactions.push(h);c._rejectReactions.push(j);break;case"has-resolution":i([h],c._result);break;case"has-rejection":i([j],c._result);break;default:throw new TypeError("unexpected")}return f.promise};return b}();// export the Promise constructor.
n(f,{Promise:A});// In Chrome 33 (and thereabouts) Promise is defined, but the
// implementation is buggy in a number of ways.  Let's check subclassing
// support to see if we have a buggy implementation.
if(!c(f.Promise,function(a){return a.resolve(42)instanceof a})){f.Promise=A}// Map and Set require a true ES5 environment
if(h){var B=function F(a){var b=typeof a;if(b==="string"){return"$"+a}else if(b==="number"){// note that -0 will get coerced to "0" when used as a property key
return a}return null};var C=function G(){// accomodate some older not-quite-ES5 browsers
return Object.create?Object.create(null):{}};var D={Map:function(){var b={};function c(a,b){this.key=a;this.value=b;this.next=null;this.prev=null}c.prototype.isRemoved=function(){return this.key===b};function d(a,b){this.head=a._head;this.i=this.head;this.kind=b}d.prototype={next:function(){var b=this.i,c=this.kind,d=this.head,e;if(this.i===a){return{value:a,done:true}}while(b.isRemoved()&&b!==d){// back up off of removed entries
b=b.prev}// advance to next unreturned element.
while(b.next!==d){b=b.next;if(!b.isRemoved()){if(c==="key"){e=b.key}else if(c==="value"){e=b.value}else{e=[b.key,b.value]}this.i=b;return{value:e,done:false}}}// once the iterator is done, it is done forever.
this.i=a;return{value:a,done:true}}};p(d.prototype);function e(){var b=this;b=r(b);if(!b._es6map){throw new TypeError("bad map")}var d=new c(null,null);// circular doubly-linked list.
d.next=d.prev=d;n(b,{_head:d,_storage:C(),_size:0});// Optionally initialize map from iterable
var e=arguments[0];if(e!==a&&e!==null){var f=s.GetIterator(e);var g=b.set;if(!s.IsCallable(g)){throw new TypeError("bad map")}while(true){var h=s.IteratorNext(f);if(h.done){break}var i=h.value;if(!s.TypeIsObject(i)){throw new TypeError("expected iterable of pairs")}g.call(b,i[0],i[1])}}return b}var f=e.prototype;n(e,{"@@create":function(a){var b=this;var c=b.prototype||f;a=a||Object.create(c);n(a,{_es6map:true});return a}});Object.defineProperty(e.prototype,"size",{configurable:true,enumerable:false,get:function(){if(typeof this._size==="undefined"){throw new TypeError("size method called on incompatible Map")}return this._size}});n(e.prototype,{get:function(b){var c=B(b);if(c!==null){// fast O(1) path
var d=this._storage[c];return d?d.value:a}var e=this._head,f=e;while((f=f.next)!==e){if(s.SameValueZero(f.key,b)){return f.value}}return a},has:function(a){var b=B(a);if(b!==null){// fast O(1) path
return typeof this._storage[b]!=="undefined"}var c=this._head,d=c;while((d=d.next)!==c){if(s.SameValueZero(d.key,a)){return true}}return false},set:function(a,b){var d=this._head,e=d,f;var g=B(a);if(g!==null){// fast O(1) path
if(typeof this._storage[g]!=="undefined"){this._storage[g].value=b;return}else{f=this._storage[g]=new c(a,b);e=d.prev}}while((e=e.next)!==d){if(s.SameValueZero(e.key,a)){e.value=b;return}}f=f||new c(a,b);if(s.SameValue(-0,a)){f.key=+0}f.next=this._head;f.prev=this._head.prev;f.prev.next=f;f.next.prev=f;this._size+=1},"delete":function(a){var c=this._head,d=c;var e=B(a);if(e!==null){// fast O(1) path
if(typeof this._storage[e]==="undefined"){return false}d=this._storage[e].prev;delete this._storage[e]}while((d=d.next)!==c){if(s.SameValueZero(d.key,a)){d.key=d.value=b;d.prev.next=d.next;d.next.prev=d.prev;this._size-=1;return true}}return false},clear:function(){this._size=0;this._storage=C();var a=this._head,c=a,d=c.next;while((c=d)!==a){c.key=c.value=b;d=c.next;c.next=c.prev=a}a.next=a.prev=a},keys:function(){return new d(this,"key")},values:function(){return new d(this,"value")},entries:function(){return new d(this,"key+value")},forEach:function(a){var b=arguments.length>1?arguments[1]:null;var c=this.entries();for(var d=c.next();!d.done;d=c.next()){a.call(b,d.value[1],d.value[0],this)}}});p(e.prototype,function(){return this.entries()});return e}(),Set:function(){// Creating a Map is expensive.  To speed up the common case of
// Sets containing only string or numeric keys, we use an object
// as backing storage and lazily create a full Map only when
// required.
var b=function e(){var b=this;b=r(b);if(!b._es6set){throw new TypeError("bad set")}n(b,{"[[SetData]]":null,_storage:C()});// Optionally initialize map from iterable
var c=arguments[0];if(c!==a&&c!==null){var d=s.GetIterator(c);var e=b.add;if(!s.IsCallable(e)){throw new TypeError("bad set")}while(true){var f=s.IteratorNext(d);if(f.done){break}var g=f.value;e.call(b,g)}}return b};var c=b.prototype;n(b,{"@@create":function(a){var b=this;var d=b.prototype||c;a=a||Object.create(d);n(a,{_es6set:true});return a}});// Switch from the object backing storage to a full Map.
var d=function f(a){if(!a["[[SetData]]"]){var b=a["[[SetData]]"]=new D.Map;Object.keys(a._storage).forEach(function(a){// fast check for leading '$'
if(a.charCodeAt(0)===36){a=a.substring(1)}else{a=+a}b.set(a,a)});a._storage=null}};Object.defineProperty(b.prototype,"size",{configurable:true,enumerable:false,get:function(){if(typeof this._storage==="undefined"){// https://github.com/paulmillr/es6-shim/issues/176
throw new TypeError("size method called on incompatible Set")}d(this);return this["[[SetData]]"].size}});n(b.prototype,{has:function(a){var b;if(this._storage&&(b=B(a))!==null){return!!this._storage[b]}d(this);return this["[[SetData]]"].has(a)},add:function(a){var b;if(this._storage&&(b=B(a))!==null){this._storage[b]=true;return}d(this);return this["[[SetData]]"].set(a,a)},"delete":function(a){var b;if(this._storage&&(b=B(a))!==null){delete this._storage[b];return}d(this);return this["[[SetData]]"]["delete"](a)},clear:function(){if(this._storage){this._storage=C();return}return this["[[SetData]]"].clear()},keys:function(){d(this);return this["[[SetData]]"].keys()},values:function(){d(this);return this["[[SetData]]"].values()},entries:function(){d(this);return this["[[SetData]]"].entries()},forEach:function(a){var b=arguments.length>1?arguments[1]:null;var c=this;d(this);this["[[SetData]]"].forEach(function(d,e){a.call(b,e,e,c)})}});p(b.prototype,function(){return this.values()});return b}()};n(f,D);if(f.Map||f.Set){/*
          - In Firefox < 23, Map#size is a function.
          - In all current Firefox, Set#entries/keys/values & Map#clear do not exist
          - https://bugzilla.mozilla.org/show_bug.cgi?id=869996
          - In Firefox 24, Map and Set do not implement forEach
          - In Firefox 25 at least, Map and Set are callable without "new"
        */
if(typeof f.Map.prototype.clear!=="function"||(new f.Set).size!==0||(new f.Map).size!==0||typeof f.Set.prototype.keys!=="function"||typeof f.Map.prototype.forEach!=="function"||typeof f.Set.prototype.forEach!=="function"||b(f.Map)||b(f.Set)||!c(f.Map,function(a){return new a([])instanceof a})){f.Map=D.Map;f.Set=D.Set}}// Shim incomplete iterator implementations.
p(Object.getPrototypeOf((new f.Map).keys()));p(Object.getPrototypeOf((new f.Set).keys()))}};if(typeof define==="function"&&typeof define.amd==="object"&&define.amd){define(f)}else{f()}})();